package smoothint2;

=head2 SYNOPSIS

PACKAGE NAME: 

AUTHOR:  

DATE:

DESCRIPTION:

Version:

=head2 USE

=head3 NOTES

=head4 Examples

=head2 SYNOPSIS

=head3 SEISMIC UNIX NOTES
 SMOOTHINT2 --- SMOOTH non-uniformly sampled INTerfaces, via the damped

  		least-squares technique					



  smoothint2 <input ninf= >output [optional parameters]		



 Required Parameters:							

 <input                 file containing original interfaces		

 >output                file containing smoothed interfaces	 	



 Optional Parameters:							

 ninf=5                number of interfaces  				

 r=100			smoothing parameter 				

 npmax=101		maximum number of points in interfaces		



 Notes:								

 The input file is an ASCII file. Each interface is represented by pairs

 (non-uniform sampling) of x and z values, with one pair of values on	

 each line, separated by spaces or tabs. Each interface is separated with

 an entry with a large negative z value for example: 1.0     -9999.	

 There is no entry for the surface. The surface is assumed to be flat  

 with z=0.								

 This is similar to a CSHOT model file without a surface entry and	

 without comments.							



 The smoothing method is analogous to a moving window averaging process

 (but not the same) with the parameter "r" being analogous to the "width

 of the window. Thus, the size of "r" must be chosen to by compatible

 with the scale (wavelengths) of the variations of the interfaces in the

 model being smoothed.							



 Example using the test data set generated by unif2: 			

 unif2 tfile "equals" tfilename							

 Compare the unsmoothed interface model:				

 unif2 < tfilename method=interpolation_method |			

	 			psimage n1=100 n2=100 d1=10 d2=10 | ...	

 To the smoothed interface model:					

 smoothint2 r=100 < tfilename | unif2 method=interpolation_method |	", 

	psimage n1=100 n2=100 d1=10 d2=10 | ...				







 Credits:

  CWP: Zhenyue Liu, Jan 1994

 Reference:

    Liu, Zhenyue, 1994, Velocity smoothing: theory and implementation, 

    Project Review, 1994, Consortium Project on Seismic Inverse Methods

    for Complex Stuctures (in review)





=head2 User's notes (Juan Lorenzo)
untested

=cut


=head2 CHANGES and their DATES

=cut

use Moose;
our $VERSION = '0.0.1';


=head2 Import packages

=cut

use L_SU_global_constants();

use SeismicUnix qw ($go $in $off $on $out $ps $to $suffix_ascii $suffix_bin $suffix_ps $suffix_segy $suffix_su);
use Project_config;


=head2 instantiation of packages

=cut

my $get					= new L_SU_global_constants();
my $Project				= new Project_config();
my $DATA_SEISMIC_SU		= $Project->DATA_SEISMIC_SU();
my $DATA_SEISMIC_BIN	= $Project->DATA_SEISMIC_BIN();
my $DATA_SEISMIC_TXT	= $Project->DATA_SEISMIC_TXT();

my $PS_SEISMIC      	= $Project->PS_SEISMIC();

my $var				= $get->var();
my $on				= $var->{_on};
my $off				= $var->{_off};
my $true			= $var->{_true};
my $false			= $var->{_false};
my $empty_string	= $var->{_empty_string};

=head2 Encapsulated
hash of private variables

=cut

my $smoothint2			= {
	_method					=> '',
	_n1					=> '',
	_ninf					=> '',
	_npmax					=> '',
	_r					=> '',
	_z					=> '',
	_Step					=> '',
	_note					=> '',

};

=head2 sub Step

collects switches and assembles bash instructions
by adding the program name

=cut

 sub  Step {

	$smoothint2->{_Step}     = 'smoothint2'.$smoothint2->{_Step};
	return ( $smoothint2->{_Step} );

 }


=head2 sub note

collects switches and assembles bash instructions
by adding the program name

=cut

 sub  note {

	$smoothint2->{_note}     = 'smoothint2'.$smoothint2->{_note};
	return ( $smoothint2->{_note} );

 }



=head2 sub clear

=cut

 sub clear {

		$smoothint2->{_method}			= '';
		$smoothint2->{_n1}			= '';
		$smoothint2->{_ninf}			= '';
		$smoothint2->{_npmax}			= '';
		$smoothint2->{_r}			= '';
		$smoothint2->{_z}			= '';
		$smoothint2->{_Step}			= '';
		$smoothint2->{_note}			= '';
 }


=head2 sub method 


=cut

 sub method {

	my ( $self,$method )		= @_;
	if ( $method ne $empty_string ) {

		$smoothint2->{_method}		= $method;
		$smoothint2->{_note}		= $smoothint2->{_note}.' method='.$smoothint2->{_method};
		$smoothint2->{_Step}		= $smoothint2->{_Step}.' method='.$smoothint2->{_method};

	} else { 
		print("smoothint2, method, missing method,\n");
	 }
 }


=head2 sub n1 


=cut

 sub n1 {

	my ( $self,$n1 )		= @_;
	if ( $n1 ne $empty_string ) {

		$smoothint2->{_n1}		= $n1;
		$smoothint2->{_note}		= $smoothint2->{_note}.' n1='.$smoothint2->{_n1};
		$smoothint2->{_Step}		= $smoothint2->{_Step}.' n1='.$smoothint2->{_n1};

	} else { 
		print("smoothint2, n1, missing n1,\n");
	 }
 }


=head2 sub ninf 


=cut

 sub ninf {

	my ( $self,$ninf )		= @_;
	if ( $ninf ne $empty_string ) {

		$smoothint2->{_ninf}		= $ninf;
		$smoothint2->{_note}		= $smoothint2->{_note}.' ninf='.$smoothint2->{_ninf};
		$smoothint2->{_Step}		= $smoothint2->{_Step}.' ninf='.$smoothint2->{_ninf};

	} else { 
		print("smoothint2, ninf, missing ninf,\n");
	 }
 }


=head2 sub npmax 


=cut

 sub npmax {

	my ( $self,$npmax )		= @_;
	if ( $npmax ne $empty_string ) {

		$smoothint2->{_npmax}		= $npmax;
		$smoothint2->{_note}		= $smoothint2->{_note}.' npmax='.$smoothint2->{_npmax};
		$smoothint2->{_Step}		= $smoothint2->{_Step}.' npmax='.$smoothint2->{_npmax};

	} else { 
		print("smoothint2, npmax, missing npmax,\n");
	 }
 }


=head2 sub r 


=cut

 sub r {

	my ( $self,$r )		= @_;
	if ( $r ne $empty_string ) {

		$smoothint2->{_r}		= $r;
		$smoothint2->{_note}		= $smoothint2->{_note}.' r='.$smoothint2->{_r};
		$smoothint2->{_Step}		= $smoothint2->{_Step}.' r='.$smoothint2->{_r};

	} else { 
		print("smoothint2, r, missing r,\n");
	 }
 }


=head2 sub z 


=cut

 sub z {

	my ( $self,$z )		= @_;
	if ( $z ne $empty_string ) {

		$smoothint2->{_z}		= $z;
		$smoothint2->{_note}		= $smoothint2->{_note}.' z='.$smoothint2->{_z};
		$smoothint2->{_Step}		= $smoothint2->{_Step}.' z='.$smoothint2->{_z};

	} else { 
		print("smoothint2, z, missing z,\n");
	 }
 }


=head2 sub get_max_index

max index = number of input variables -1
 
=cut
 
sub get_max_index {
 	  my ($self) = @_;
	my $max_index = 5;

    return($max_index);
}
 
 
1;
